{"/docs/how-it-works":{"title":"How does it work?","data":{"":"MaiMap connects to your Git organization and imports your code for analysis. Once your codebases have been analyzed the resulting contextual map is stored in a graph database. This data can be accessed via a web interface and visualized in an interactive graph. An MCP server can be installed locally, to serve as a gateway between your local LLM and MaiMap's API.","details#Details":"","1-ast-parsing#1. AST parsing":"For each repo, the code is parsed into an abstract syntax tree (AST). The AST is then saved to a graph database. This allows MaiMap to quickly return call paths and data flows for the operations that your services perform.","2-source-and-sink-analysis#2. Source and Sink Analysis":"Rule-based analysis is applied to the AST to identify sources and sinks in your codebase. These rules are language-specific which is why MaiMap only works for a certain set of languages.LLM-based analysis is done by MaiMap's own internal LLM. It does further classification of AST nodes, so it can pick up where rule-based analysis may have failed to identify behaviors and patterns.Nodes are labelled based on any sources or sinks they are identified as belonging to. Multiple nodes can have the same label.Examples of sources and sinks that can be identified are:\nHTTP endpoints & requests\ngRPC methods & calls\nKafka, PubSub, EventBus, RabbitMQ consumers & publishers\nReading & writing to SQL databases\nReading & writing to NoSQL databases","3-cross-repo-analysis#3. Cross-Repo Analysis":"For each repo, its sinks are compared with the sources of every other repo. If a match is identified then a connection from that service to the other is saved in the graph database. This allows us to build up a graph of connections between services.","4-results#4. Results":"The results of these analyses are returned in two ways:\nA web interface gives the user access to view the analyzed data. Including a visual graph of the services and their connections.\nAn MCP server is used to connect your LLM to our API, which gives the LLM access to their organization's graph."}},"/docs":{"title":"Introduction","data":{"":"MaiMap is a service which analyzes your entire distributed codebase and provides that information to you via a web interface and empowers your LLM via an MCP server.","how-is-it-different-from-existing-ai-solutions#How is it different from existing AI solutions?":"Most existing LLM-based code editors use a naive approach of providing their AI with text-based search capabilities for an entire codebase. MaiMap uses a combination of rule-based and LLM-based static code analysis to parse your codebase(s) into a deep contextual map. That map is stored in a graph database and served to your LLM model via an MCP server.This allows a MaiMap-enabled LLM to answer prompts that they would otherwise be incapable of answering. For example:\n\"Describe the overall architecture of my microservices\"\n\"What are the bounded contexts of my services?\"\n\"Which endpoints in the auth-service query the user_permissions table in Postgres?\"\n\"Trace the series of events, API calls and side-effects that happen when a user signs up\""}},"/docs/release":{"title":"When will it be released?","data":{"":"MaiMap is currently in prototype phase. We are running it successfully against Go-based microservices and are working on getting this product ready for production usage. Once it is ready we will move on to supporting more languages like Java, TypeScript, NodeJS, Python, C# and more.We are a team of three software engineers who initially built this product for ourselves. We find it incredibly useful in our day-to-day work but we want to hear from you as to how you would like to use this product.So if you haven't already, please take the time to fill out our customer survey form and get three months' worth of MaiMap Pro for free!"}}}